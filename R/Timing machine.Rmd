---
title: "Timing machine"
output: html_notebook
---

## Input generator
```{r}
library(igraph)
# fits lognormal distribution to a graph and returns function generating vector[size] of samples from that distribution
lognormSampler <- function(original) {
  require(fitdistrplus)
  fit <- fitdist(degree(original) + 1, "lnorm")
  function(size) {
    rlnorm(size,
           mean = fit$estimate["meanlog"],
           sd = fit$estimate["sdlog"])
  } # returns a function
}
```

```{r}
algoDistances <- function(g, params) {
  require(igraph)
  distances(g)
}
```

```{r}
# return a graph with given size and edge distribution. InputGenerator when provided with distrSampler
graphGenerator <- function(size, params) {
  require(igraph)
  new_degs <-  params$distrSampler(size) %>% round
  new_degs[new_degs > size] <- size # trim meaningless values
  if(sum(new_degs) %% 2 != 0){ new_degs[1] <- new_degs[1] + 1} # undirected graph must have even sum of orders
  g5 <- sample_degseq(out.deg = new_degs) %>%
    as.directed(mode = "arbitrary") %>%  # generated undirected graph! Fix?
    simplify(remove.loops = T)  # remove edges with from=to
  g5
}
```

## Run series of sizes
```{r}
sizes <- c(2, 4, 6, 8, 100)
# algo signature: a(input, params) output will be ignored; inputArgs will be passed as params
# inputGenerator signature: f(size, params) returns input; algArgs will be passed as params
 runSizes <- function(algo, inputGenerator, sizes, timeLimit, algArgs = c(), inputArgs = NULL) {
  startTime  <- Sys.time()
  edges <- numeric(length = length(sizes)) # breaks generality of this function. Fix it later
  nodes <- numeric(length = length(sizes))
  elapsed <- numeric(length = length(sizes))
  
  for(i in 1:length(sizes)){
    g <- inputGenerator(sizes[i], inputArgs)
    elapsed[i] <- system.time(
      algo(g, algArgs)
    )["elapsed"]
    nodes[i] <- gorder(g)  # replace with a generic function call
    edges[i] <- gsize(g)
    if(difftime(Sys.time(), startTime, units = "secs") > timeLimit){
      elapsed <- elapsed[1:i]
      nodes <- nodes[1:i]  # this renders difficult in implementation as generic
      edges <- edges[1:i]
      print(c("Timed out at i=", i))
      break
    }
  }
  return(data.frame(edges, nodes, elapsed))
  # add alg name, processors + architecture later
}
```

```{r}
sizes <- seq(500,20000,by=200)
sampler <- lognormSampler(n5)
res <- runSizes(algoDistances, graphGenerator, sizes, 20, inputArgs = c(distrSampler = sampler), algArgs = c())
saveRDS(res, file="from500to20000in5min.rds")
```

```{r}
plot(res$nodes, res$elapsed)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
