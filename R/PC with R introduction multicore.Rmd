---
title: "PC for DS with R: Introduction"
output: html_notebook
---

Now it's time to introduce parallelism, using parallel/snow methods.

```{r}
library(parallel)

doinchunk <- function(start, chunks, lnks){
  tot <-0
  nr <- nrow(lnks)
  for(i in (start:max(start-1 + chunks, length(lnks)))){
    tmp <- lnks[(i+1):nr,] %*% lnks[i,]
    tot <- tot+sum(tmp)
  }
}
```

```{r}
mopPreschedule <- function(lnks, cores){
  nr <- nrow(lnks)
  tots <- mclapply(1:(nr-1), doinchunk, 1, lnks, mc.cores=cores, mc.preschedule = T)
  tots
  Reduce(sum, tots)/nr
}

mopDynamic <- function(lnks, cores, chunk){
  nr <- nrow(lnks)
  ichunks <- seq(1, nr-1, chunk)
  tots <- mclapply(ichunks, doinchunk, chunk, lnks, mc.cores=cores, mc.preschedule = F)
  Reduce(sum, tots)/nr
}
```

```{r}
compareChunks <- function(nr, times, chunk=10){
  lnks <- matrix(sample(0:1, nr**2, replace = TRUE), nrow=nr)
  microbenchmark(mopDynamic(lnks, 4, chunk), unit="s", times=times)

}
# compare parallel and serial execution times
compareChunks(100, 1)
compareChunks(200, 5)
compareChunks(400, 2)
```
